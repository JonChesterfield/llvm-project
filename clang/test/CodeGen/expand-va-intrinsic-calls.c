// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py

// REQUIRES: x86-registered-target
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -std=c23 -O1 -mllvm -expand-va-intrinsics-disable=true -emit-llvm -o - %s | FileCheck %s

// The IR tests with similar name under specific target directories can be recreated from this
// source

typedef __builtin_va_list va_list;
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#define va_start(ap, ...) __builtin_va_start(ap, 0)
#define va_end(ap) __builtin_va_end(ap)
#define va_arg(ap, type) __builtin_va_arg(ap, type)

void wrapped(va_list);

// CHECK-LABEL: @codegen_for_copy(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CP:%.*]] = alloca [1 x %struct.__va_list_tag], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 24, ptr nonnull [[CP]]) #[[ATTR5:[0-9]+]]
// CHECK-NEXT:    call void @llvm.va_copy(ptr nonnull [[CP]], ptr [[X:%.*]])
// CHECK-NEXT:    call void @wrapped(ptr noundef nonnull [[CP]]) #[[ATTR5]]
// CHECK-NEXT:    call void @llvm.va_end(ptr [[CP]])
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 24, ptr nonnull [[CP]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void codegen_for_copy(va_list x)
{
  va_list cp;
  va_copy(cp, x);
  wrapped(cp);
  va_end(cp);
}


// CHECK-LABEL: @vararg(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VA:%.*]] = alloca [1 x %struct.__va_list_tag], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 24, ptr nonnull [[VA]]) #[[ATTR5]]
// CHECK-NEXT:    call void @llvm.va_start(ptr nonnull [[VA]])
// CHECK-NEXT:    call void @wrapped(ptr noundef nonnull [[VA]]) #[[ATTR5]]
// CHECK-NEXT:    call void @llvm.va_end(ptr [[VA]])
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 24, ptr nonnull [[VA]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
static void vararg(...)
{
  va_list va;
  __builtin_va_start(va, 0);
  wrapped(va);
  va_end(va);
}

typedef float float4 __attribute__((__vector_size__(16), __aligned__(16)));

typedef int i32;

// CHECK-LABEL: @single_i32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(i32 noundef [[X:%.*]])
// CHECK-NEXT:    ret void
//
void single_i32(i32 x)
{
  vararg(x);
}

// CHECK-LABEL: @single_double(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(double noundef [[X:%.*]])
// CHECK-NEXT:    ret void
//
void single_double(double x)
{
  vararg(x);
}

// CHECK-LABEL: @single_float4(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(<4 x float> noundef [[X:%.*]])
// CHECK-NEXT:    ret void
//
void single_float4(float4 x)
{
  vararg(x);
}

// CHECK-LABEL: @i32_double(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(i32 noundef [[X:%.*]], double noundef [[Y:%.*]])
// CHECK-NEXT:    ret void
//
void i32_double(i32 x, double y)
{
  vararg(x, y);
}

// CHECK-LABEL: @double_i32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(double noundef [[X:%.*]], i32 noundef [[Y:%.*]])
// CHECK-NEXT:    ret void
//
void double_i32(double x, i32 y)
{
  vararg(x, y);
}

// CHECK-LABEL: @i32_float4(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(i32 noundef [[X:%.*]], <4 x float> noundef [[Y:%.*]])
// CHECK-NEXT:    ret void
//
void i32_float4(i32 x, float4 y)
{
  vararg(x, y);
}

// CHECK-LABEL: @float4_i32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(<4 x float> noundef [[X:%.*]], i32 noundef [[Y:%.*]])
// CHECK-NEXT:    ret void
//
void float4_i32(float4 x, i32 y)
{
  vararg(x, y);
}

typedef struct {
  char c;
  short s;
  i32 i;
  long l;
  float f;
  double d;
}  libcS;

// CHECK-LABEL: @i32_libcS(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(i32 noundef [[X:%.*]], ptr noundef nonnull byval([[STRUCT_LIBCS:%.*]]) align 8 [[Y:%.*]])
// CHECK-NEXT:    ret void
//
void i32_libcS(i32 x, libcS y)
{
  vararg(x, y);
}

// CHECK-LABEL: @libcS_i32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void (...) @vararg(ptr noundef nonnull byval([[STRUCT_LIBCS:%.*]]) align 8 [[X:%.*]], i32 noundef [[Y:%.*]])
// CHECK-NEXT:    ret void
//
void libcS_i32(libcS x, i32 y)
{
  vararg(x, y);
}
