// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// todo, need a single opt invocation, cut down O1 to something like inline/sroa/gvn. Or have clang -O1 suffice

// -Wno-varargs can be removed when issue ### is resolved
// (todo, raise issue for warning: second argument to 'va_start' is not the last named parameter
//   when it's a literal zero)

// RUN: %clang_cc1 -triple wasm32-unknown-unknown -Wno-varargs -O1 -emit-llvm -o - %s |  FileCheck %s --check-prefixes=CHECK,STRUCT

// RUN: %clang_cc1 -triple i386-unknown-linux-gnu -Wno-varargs -O1 -emit-llvm -o - %s |  FileCheck %s --check-prefixes=CHECK,STRUCT
// RUN: %clang_cc1 -triple i386-apple-darwin -Wno-varargs -O1 -emit-llvm -o - %s |  FileCheck %s --check-prefixes=CHECK,STRUCT

// RUN: %clang_cc1 -triple x86_64-linux-gnu -Wno-varargs -O2 -emit-llvm -o - %s |  FileCheck %s --check-prefixes=CHECK,STRUCT
// RUN: %clang_cc1 -triple x86_64-apple-darwin -Wno-varargs -O2 -emit-llvm -o - %s |  FileCheck %s --check-prefixes=CHECK,STRUCT

// RUN: %clang_cc1 -triple nvptx64-nvidia-cuda -Wno-varargs -O1 -emit-llvm -o - %s |  FileCheck %s --check-prefixes=CHECK


// Triple amdgcn-amd-amdhsa is left out until addrspace-cast induced codegen mess is fixed




// The clang test suite has _lots_ of windows related triples in it
// 'x86_64-pc-windows-msvc|i686-windows-msvc|thumbv7-windows|aarch64-windows|i686-windows|x86_64-windows|x86_64-unknown-windows-msvc|i386-windows-pc|x86_64--windows-msvc|i686--windows-msvc|x86_64-unknown-windows-gnu|i686-unknown-windows-msvc|i686-unknown-windows-gnu|arm64ec-pc-windows-msvc19.20.0|i686-pc-windows-msvc19.14.0|i686-pc-windows|x86_64--windows-gnu|i686--windows-gnu|thumbv7--windows|i386-windows|x86_64-unknown-windows-pc|i686--windows|x86_64--windows|i686-w64-windows-gnu'

// Might be detecting an inconsistency - maybe different alignment
// Presently failing on an unusual calling convention

// i686 windows emits suboptimal codegen. sroa removes a field from a struct which misaligns a field which blocks store/load forwarding
// R__N: %clang_cc1 -triple i686-windows-msvc -Wno-varargs -O1 -emit-llvm -o - %s | opt --passes=expand-variadics | opt -S -O1 | FileCheck %s --check-prefixes=CHECK,X86Windows


// 64 bit windows va_arg passes most type indirectly but the call instruction uses the types by value
// ___: %clang_cc1 -triple x86_64-pc-windows-msvc -Wno-varargs -O1 -emit-llvm -o - %s | opt --passes=expand-variadics | opt -S -O1 | FileCheck %s --check-prefixes=CHECK




// Not yet implemented on arm
// Also there are various x86 variants that should be in the triple

// Checks for consistency between clang and expand-va-intrinics
// 1. Use clang to lower va_arg
// 2. Use expand-variadics to lower the rest of the variadic operations
// 3. Use opt -O1 to simplify the functions to ret %arg
// The simplification to ret %arg will fail when the two are not consistent, modulo bugs elsewhere.

#include <stdarg.h>
#include <stdint.h>

template <typename X, typename Y>
static X first(...) {
  va_list va;
  __builtin_va_start(va, 0);
  X r = va_arg(va, X);
  va_end(va);
  return r;
}

template <typename X, typename Y>
static Y second(...) {
  va_list va;
  __builtin_va_start(va, 0);
  va_arg(va, X);
  Y r = va_arg(va, Y);
  va_end(va);
  return r;
}

template <typename X, typename Y>
static void first_indirect(X* out, ...) {
  va_list va;
  __builtin_va_start(va, 0);
  *out = va_arg(va, X);
  va_end(va);
}

template <typename X, typename Y>
static void second_indirect(Y* out, ...) {
  va_list va;
  __builtin_va_start(va, 0);
  va_arg(va, X);
  *out = va_arg(va, Y);
  va_end(va);
}




typedef float float4 __attribute__((__vector_size__(16), __aligned__(16)));
typedef float float8 __attribute__((__vector_size__(32), __aligned__(32)));
typedef float float16 __attribute__((__vector_size__(64), __aligned__(64)));
typedef float float32 __attribute__((__vector_size__(128), __aligned__(128)));


typedef uint64_t ulong2 __attribute__((__vector_size__(16), __aligned__(16)));

extern "C"
{

// CHECK-LABEL: define {{[^@]+}}@first_pair_i32
// CHECK-SAME: (i32 noundef returned [[X:%.*]], i32 noundef [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[X]]
//
int first_pair_i32(int x, int y)
{
  return first<int,int>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@second_pair_i32
// CHECK-SAME: (i32 noundef [[X:%.*]], i32 noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[Y]]
//
int second_pair_i32(int x, int y)
{
  return second<int,int>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@first_pair_f64
// CHECK-SAME: (double noundef returned [[X:%.*]], double noundef [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret double [[X]]
//
double first_pair_f64(double x, double y)
{
  return first<double,double>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@second_pair_f64
// CHECK-SAME: (double noundef [[X:%.*]], double noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret double [[Y]]
//
double second_pair_f64(double x, double y)
{
  return second<double,double>(x, y);
}

}

extern "C"
{
// CHECK-LABEL: define {{[^@]+}}@first_i32_f64
// CHECK-SAME: (i32 noundef returned [[X:%.*]], double noundef [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[X]]
//
int first_i32_f64(int x, double y)
{
  return first<int,double>(x, y);
}


// CHECK-LABEL: define {{[^@]+}}@second_i32_f64
// CHECK-SAME: (i32 noundef [[X:%.*]], double noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret double [[Y]]
//
double second_i32_f64(int x, double y)
{
  return second<int,double>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@first_f64_i32
// CHECK-SAME: (double noundef returned [[X:%.*]], i32 noundef [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret double [[X]]
//
double first_f64_i32(double x, int y)
{
  return first<double,int>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@second_f64_i32
// CHECK-SAME: (double noundef [[X:%.*]], i32 noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[Y]]
//
int second_f64_i32(double x, int y)
{
  return second<double,int>(x, y);
}
}


extern "C"
{

// CHECK-LABEL: define {{[^@]+}}@first_i32_ulong2
// CHECK-SAME: (i32 noundef returned [[X:%.*]], ptr nocapture noundef readonly [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[X]]
//
int first_i32_ulong2(int x, ulong2 * y)
{
  return first<int,ulong2>(x, *y);
}

// CHECK-LABEL: define {{[^@]+}}@second_i32_ulong2
// CHECK-SAME: (i32 noundef [[X:%.*]], ptr nocapture noundef readonly [[Y:%.*]], ptr nocapture noundef writeonly [[R:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i64>, ptr [[Y]], align 16, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    store <2 x i64> [[TMP0]], ptr [[R]], align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret void
//
void second_i32_ulong2(int x, ulong2 * y, ulong2* r)
{
  *r = second<int,ulong2>(x, *y);
}


// CHECK-LABEL: define {{[^@]+}}@first_ulong2_i32
// CHECK-SAME: (ptr nocapture noundef readonly [[X:%.*]], i32 noundef [[Y:%.*]], ptr nocapture noundef writeonly [[R:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i64>, ptr [[X]], align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    store <2 x i64> [[TMP0]], ptr [[R]], align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret void
//
  void first_ulong2_i32(ulong2* x, int y, ulong2* r)
{
 *r =first<ulong2,int>(*x, y);
}

// CHECK-LABEL: define {{[^@]+}}@second_ulong2_i32
// CHECK-SAME: (ptr nocapture noundef readonly [[X:%.*]], i32 noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[Y]]
//
int second_ulong2_i32(ulong2* x, int y)
{
  return second<ulong2,int>(*x, y);
}

}


typedef struct {
  char c;
  short s;
  int i;
  long l;
  float f;
  double d;
} libcS;

extern "C"
{


// libcS totally miscompiling on x86 i386-unknown-linux-gnu
  
// STRUCT-LABEL: define {{[^@]+}}@first_i32_libcS
// STRUCT-SAME: (i32 noundef returned [[X:%.*]], ptr nocapture noundef readonly [[Y:%.*]])
// STRUCT-LABEL:{{.}}:
// STRUCT-NEXT:    ret i32 [[X]]
//
int first_i32_libcS(int x, libcS * y)
{
  return first<int,libcS>(x, *y);
}


// STRUCT-LABEL: define {{[^@]+}}@second_i32_libcS
// STRUCT-SAME: (i32 noundef [[X:%.*]], ptr nocapture noundef readonly [[Y:%.*]], ptr nocapture noundef writeonly [[R:%.*]])
// STRUCT-LABEL:{{.}}:
// STRUCT-NEXT:    call void @llvm.memmove{{.*}}(ptr {{.*}} [[R]], ptr {{.*}} [[Y]], {{.*}}, i1 false)
// STRUCT-NEXT:    ret void
//
void second_i32_libcS(int x, libcS * y, libcS* r)
{
  *r = second<int,libcS>(x, *y);
}


// STRUCT-LABEL: define {{[^@]+}}@first_libcS_i32
// STRUCT-SAME: (ptr nocapture noundef readonly [[X:%.*]], i32 noundef [[Y:%.*]], ptr nocapture noundef writeonly [[R:%.*]])
// STRUCT-LABEL:{{.}}:
// STRUCT-NEXT:    call void @llvm.memmove{{.*}}(ptr {{.*}} [[R]], ptr {{.*}} [[X]], {{.*}}, i1 false)
// STRUCT-NEXT:    ret void
//
void first_libcS_i32(libcS* x, int y, libcS* r)
{
  *r =first<libcS,int>(*x, y);
}

// STRUCT-LABEL: define {{[^@]+}}@second_libcS_i32
// STRUCT-SAME: (ptr nocapture noundef readonly [[X:%.*]], i32 noundef returned [[Y:%.*]])
// STRUCT-LABEL:{{.}}:
// STRUCT-NEXT:    ret i32 [[Y]]
//
int second_libcS_i32(libcS* x, int y)
{
  return second<libcS,int>(*x, y);
}


}
