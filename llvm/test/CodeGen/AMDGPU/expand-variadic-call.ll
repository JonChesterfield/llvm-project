; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: -p --function-signature
; RUN: opt -S --passes=expand-variadics -expand-variadics-abi=true < %s | FileCheck %s
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-p7:160:256:256:32-p8:128:128-p9:192:256:256:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7:8:9"
target triple = "amdgcn-amd-amdhsa"

; Check the variables are lowered to the locations this target expects

; The types show the call frames

@vararg_ptr = hidden addrspace(1) global ptr @vararg, align 8

define hidden void @codegen_for_copy(ptr noundef %x) {
; CHECK-LABEL: define {{[^@]+}}@codegen_for_copy(ptr noundef %x) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %x.addr = alloca ptr, align 8, addrspace(5)
; CHECK-NEXT:    %cp = alloca ptr, align 8, addrspace(5)
; CHECK-NEXT:    %x.addr.ascast = addrspacecast ptr addrspace(5) %x.addr to ptr
; CHECK-NEXT:    %cp.ascast = addrspacecast ptr addrspace(5) %cp to ptr
; CHECK-NEXT:    store ptr %x, ptr addrspace(5) %x.addr, align 8, !tbaa !3
; CHECK-NEXT:    call void @llvm.lifetime.start.p5(i64 8, ptr addrspace(5) %cp) #3
; CHECK-NEXT:    call void @llvm.memcpy.inline.p0.p0.i32(ptr %cp.ascast, ptr %x.addr.ascast, i32 8, i1 false)
; CHECK-NEXT:    %0 = load ptr, ptr addrspace(5) %cp, align 8, !tbaa !3
; CHECK-NEXT:    call void @wrapped(ptr noundef %0) #3
; CHECK-NEXT:    call void @llvm.lifetime.end.p5(i64 8, ptr addrspace(5) %cp) #3
; CHECK-NEXT:    ret void
;
entry:
  %x.addr = alloca ptr, align 8, addrspace(5)
  %cp = alloca ptr, align 8, addrspace(5)
  %x.addr.ascast = addrspacecast ptr addrspace(5) %x.addr to ptr
  %cp.ascast = addrspacecast ptr addrspace(5) %cp to ptr
  store ptr %x, ptr addrspace(5) %x.addr, align 8, !tbaa !4
  call void @llvm.lifetime.start.p5(i64 8, ptr addrspace(5) %cp) #2
  call void @llvm.va_copy(ptr %cp.ascast, ptr nonnull %x.addr.ascast)
  %0 = load ptr, ptr addrspace(5) %cp, align 8, !tbaa !4
  call void @wrapped(ptr noundef %0) #2
  call void @llvm.va_end(ptr %cp.ascast)
  call void @llvm.lifetime.end.p5(i64 8, ptr addrspace(5) %cp) #2
  ret void
}

declare void @llvm.lifetime.start.p5(i64 immarg, ptr addrspace(5) nocapture) #0

declare void @llvm.va_copy(ptr, ptr) #1

declare hidden void @wrapped(ptr noundef)

declare void @llvm.va_end(ptr) #1

declare void @llvm.lifetime.end.p5(i64 immarg, ptr addrspace(5) nocapture) #0

define hidden void @vararg(...) {
; CHECK-LABEL: define {{[^@]+}}@vararg(ptr noalias %varargs) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %va = alloca ptr, align 8, addrspace(5)
; CHECK-NEXT:    %va.ascast = addrspacecast ptr addrspace(5) %va to ptr
; CHECK-NEXT:    call void @llvm.lifetime.start.p5(i64 8, ptr addrspace(5) %va) #3
; CHECK-NEXT:    store ptr %varargs, ptr %va.ascast, align 8
; CHECK-NEXT:    %0 = load ptr, ptr addrspace(5) %va, align 8, !tbaa !3
; CHECK-NEXT:    call void @wrapped(ptr noundef %0) #3
; CHECK-NEXT:    call void @llvm.lifetime.end.p5(i64 8, ptr addrspace(5) %va) #3
; CHECK-NEXT:    ret void
;
entry:
  %va = alloca ptr, align 8, addrspace(5)
  %va.ascast = addrspacecast ptr addrspace(5) %va to ptr
  call void @llvm.lifetime.start.p5(i64 8, ptr addrspace(5) %va) #2
  call void @llvm.va_start(ptr %va.ascast)
  %0 = load ptr, ptr addrspace(5) %va, align 8, !tbaa !4
  call void @wrapped(ptr noundef %0) #2
  call void @llvm.va_end(ptr %va.ascast)
  call void @llvm.lifetime.end.p5(i64 8, ptr addrspace(5) %va) #2
  ret void
}

declare void @llvm.va_start(ptr) #1

define hidden void @single_i32(i32 noundef %x) {
; CHECK-LABEL: define {{[^@]+}}@single_i32(i32 noundef %x) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %single_i32.vararg, align 4, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %single_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i32 %x, ptr addrspace(5) %0, align 4
; CHECK-NEXT:    %1 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %1) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(i32 noundef %x) #2
  ret void
}

define hidden void @single_double(double noundef %x) {
; CHECK-LABEL: define {{[^@]+}}@single_double(double noundef %x) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %single_double.vararg, align 8, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %single_double.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store double %x, ptr addrspace(5) %0, align 8
; CHECK-NEXT:    %1 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %1) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(double noundef %x) #2
  ret void
}

define hidden void @single_v4f32(<4 x float> noundef %x) {
; CHECK-LABEL: define {{[^@]+}}@single_v4f32(<4 x float> noundef %x) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %single_v4f32.vararg, align 16, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %single_v4f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store <4 x float> %x, ptr addrspace(5) %0, align 16
; CHECK-NEXT:    %1 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %1) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(<4 x float> noundef %x) #2
  ret void
}

define hidden void @single_v8f32(<8 x float> noundef %x) {
; CHECK-LABEL: define {{[^@]+}}@single_v8f32(<8 x float> noundef %x) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %single_v8f32.vararg, align 32, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %single_v8f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store <8 x float> %x, ptr addrspace(5) %0, align 32
; CHECK-NEXT:    %1 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %1) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(<8 x float> noundef %x) #2
  ret void
}

define hidden void @single_v16f32(<16 x float> noundef %x) {
; CHECK-LABEL: define {{[^@]+}}@single_v16f32(<16 x float> noundef %x) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %single_v16f32.vararg, align 64, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %single_v16f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store <16 x float> %x, ptr addrspace(5) %0, align 64
; CHECK-NEXT:    %1 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %1) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(<16 x float> noundef %x) #2
  ret void
}

define hidden void @single_v32f32(<32 x float> noundef %x) {
; CHECK-LABEL: define {{[^@]+}}@single_v32f32(<32 x float> noundef %x) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %single_v32f32.vararg, align 128, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %single_v32f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store <32 x float> %x, ptr addrspace(5) %0, align 128
; CHECK-NEXT:    %1 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %1) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(<32 x float> noundef %x) #2
  ret void
}

define hidden void @i32_double(i32 noundef %x, double noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@i32_double(i32 noundef %x, double noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %i32_double.vararg, align 8, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %i32_double.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i32 %x, ptr addrspace(5) %0, align 4
; CHECK-NEXT:    %1 = getelementptr inbounds %i32_double.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 2
; CHECK-NEXT:    store double %y, ptr addrspace(5) %1, align 8
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(i32 noundef %x, double noundef %y) #2
  ret void
}

define hidden void @double_i32(double noundef %x, i32 noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@double_i32(double noundef %x, i32 noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %double_i32.vararg, align 8, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %double_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store double %x, ptr addrspace(5) %0, align 8
; CHECK-NEXT:    %1 = getelementptr inbounds %double_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 1
; CHECK-NEXT:    store i32 %y, ptr addrspace(5) %1, align 4
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(double noundef %x, i32 noundef %y) #2
  ret void
}

define hidden void @i32_libcS(i32 noundef %x, i8 %y.coerce0, i16 %y.coerce1, i32 %y.coerce2, i64 %y.coerce3, float %y.coerce4, double %y.coerce5) {
; CHECK-LABEL: define {{[^@]+}}@i32_libcS(i32 noundef %x, i8 %y.coerce0, i16 %y.coerce1, i32 %y.coerce2, i64 %y.coerce3, float %y.coerce4, double %y.coerce5) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %i32_libcS.vararg, align 8, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %i32_libcS.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i32 %x, ptr addrspace(5) %0, align 4
; CHECK-NEXT:    %1 = getelementptr inbounds %i32_libcS.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 1
; CHECK-NEXT:    store i8 %y.coerce0, ptr addrspace(5) %1, align 1
; CHECK-NEXT:    %2 = getelementptr inbounds %i32_libcS.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 3
; CHECK-NEXT:    store i16 %y.coerce1, ptr addrspace(5) %2, align 2
; CHECK-NEXT:    %3 = getelementptr inbounds %i32_libcS.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 4
; CHECK-NEXT:    store i32 %y.coerce2, ptr addrspace(5) %3, align 4
; CHECK-NEXT:    %4 = getelementptr inbounds %i32_libcS.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 6
; CHECK-NEXT:    store i64 %y.coerce3, ptr addrspace(5) %4, align 8
; CHECK-NEXT:    %5 = getelementptr inbounds %i32_libcS.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 7
; CHECK-NEXT:    store float %y.coerce4, ptr addrspace(5) %5, align 4
; CHECK-NEXT:    %6 = getelementptr inbounds %i32_libcS.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 9
; CHECK-NEXT:    store double %y.coerce5, ptr addrspace(5) %6, align 8
; CHECK-NEXT:    %7 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %7) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(i32 noundef %x, i8 %y.coerce0, i16 %y.coerce1, i32 %y.coerce2, i64 %y.coerce3, float %y.coerce4, double %y.coerce5) #2
  ret void
}

define hidden void @libcS_i32(i8 %x.coerce0, i16 %x.coerce1, i32 %x.coerce2, i64 %x.coerce3, float %x.coerce4, double %x.coerce5, i32 noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@libcS_i32(i8 %x.coerce0, i16 %x.coerce1, i32 %x.coerce2, i64 %x.coerce3, float %x.coerce4, double %x.coerce5, i32 noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %libcS_i32.vararg, align 8, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %libcS_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i8 %x.coerce0, ptr addrspace(5) %0, align 1
; CHECK-NEXT:    %1 = getelementptr inbounds %libcS_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 2
; CHECK-NEXT:    store i16 %x.coerce1, ptr addrspace(5) %1, align 2
; CHECK-NEXT:    %2 = getelementptr inbounds %libcS_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 3
; CHECK-NEXT:    store i32 %x.coerce2, ptr addrspace(5) %2, align 4
; CHECK-NEXT:    %3 = getelementptr inbounds %libcS_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 4
; CHECK-NEXT:    store i64 %x.coerce3, ptr addrspace(5) %3, align 8
; CHECK-NEXT:    %4 = getelementptr inbounds %libcS_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 5
; CHECK-NEXT:    store float %x.coerce4, ptr addrspace(5) %4, align 4
; CHECK-NEXT:    %5 = getelementptr inbounds %libcS_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 7
; CHECK-NEXT:    store double %x.coerce5, ptr addrspace(5) %5, align 8
; CHECK-NEXT:    %6 = getelementptr inbounds %libcS_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 8
; CHECK-NEXT:    store i32 %y, ptr addrspace(5) %6, align 4
; CHECK-NEXT:    %7 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %7) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(i8 %x.coerce0, i16 %x.coerce1, i32 %x.coerce2, i64 %x.coerce3, float %x.coerce4, double %x.coerce5, i32 noundef %y) #2
  ret void
}

define hidden void @i32_v4f32(i32 noundef %x, <4 x float> noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@i32_v4f32(i32 noundef %x, <4 x float> noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %i32_v4f32.vararg, align 16, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %i32_v4f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i32 %x, ptr addrspace(5) %0, align 4
; CHECK-NEXT:    %1 = getelementptr inbounds %i32_v4f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 2
; CHECK-NEXT:    store <4 x float> %y, ptr addrspace(5) %1, align 16
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(i32 noundef %x, <4 x float> noundef %y) #2
  ret void
}

define hidden void @v4f32_i32(<4 x float> noundef %x, i32 noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@v4f32_i32(<4 x float> noundef %x, i32 noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %v4f32_i32.vararg, align 16, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %v4f32_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store <4 x float> %x, ptr addrspace(5) %0, align 16
; CHECK-NEXT:    %1 = getelementptr inbounds %v4f32_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 1
; CHECK-NEXT:    store i32 %y, ptr addrspace(5) %1, align 4
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(<4 x float> noundef %x, i32 noundef %y) #2
  ret void
}

define hidden void @i32_v8f32(i32 noundef %x, <8 x float> noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@i32_v8f32(i32 noundef %x, <8 x float> noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %i32_v8f32.vararg, align 32, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %i32_v8f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i32 %x, ptr addrspace(5) %0, align 4
; CHECK-NEXT:    %1 = getelementptr inbounds %i32_v8f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 2
; CHECK-NEXT:    store <8 x float> %y, ptr addrspace(5) %1, align 32
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(i32 noundef %x, <8 x float> noundef %y) #2
  ret void
}

define hidden void @v8f32_i32(<8 x float> noundef %x, i32 noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@v8f32_i32(<8 x float> noundef %x, i32 noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %v8f32_i32.vararg, align 32, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %v8f32_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store <8 x float> %x, ptr addrspace(5) %0, align 32
; CHECK-NEXT:    %1 = getelementptr inbounds %v8f32_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 1
; CHECK-NEXT:    store i32 %y, ptr addrspace(5) %1, align 4
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(<8 x float> noundef %x, i32 noundef %y) #2
  ret void
}

define hidden void @i32_v16f32(i32 noundef %x, <16 x float> noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@i32_v16f32(i32 noundef %x, <16 x float> noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %i32_v16f32.vararg, align 64, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %i32_v16f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i32 %x, ptr addrspace(5) %0, align 4
; CHECK-NEXT:    %1 = getelementptr inbounds %i32_v16f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 2
; CHECK-NEXT:    store <16 x float> %y, ptr addrspace(5) %1, align 64
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(i32 noundef %x, <16 x float> noundef %y) #2
  ret void
}

define hidden void @v16f32_i32(<16 x float> noundef %x, i32 noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@v16f32_i32(<16 x float> noundef %x, i32 noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %v16f32_i32.vararg, align 64, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %v16f32_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store <16 x float> %x, ptr addrspace(5) %0, align 64
; CHECK-NEXT:    %1 = getelementptr inbounds %v16f32_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 1
; CHECK-NEXT:    store i32 %y, ptr addrspace(5) %1, align 4
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(<16 x float> noundef %x, i32 noundef %y) #2
  ret void
}

define hidden void @i32_v32f32(i32 noundef %x, <32 x float> noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@i32_v32f32(i32 noundef %x, <32 x float> noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %i32_v32f32.vararg, align 128, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %i32_v32f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i32 %x, ptr addrspace(5) %0, align 4
; CHECK-NEXT:    %1 = getelementptr inbounds %i32_v32f32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 2
; CHECK-NEXT:    store <32 x float> %y, ptr addrspace(5) %1, align 128
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(i32 noundef %x, <32 x float> noundef %y) #2
  ret void
}

define hidden void @v32f32_i32(<32 x float> noundef %x, i32 noundef %y) {
; CHECK-LABEL: define {{[^@]+}}@v32f32_i32(<32 x float> noundef %x, i32 noundef %y) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %v32f32_i32.vararg, align 128, addrspace(5)
; CHECK-NEXT:    %0 = getelementptr inbounds %v32f32_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store <32 x float> %x, ptr addrspace(5) %0, align 128
; CHECK-NEXT:    %1 = getelementptr inbounds %v32f32_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 1
; CHECK-NEXT:    store i32 %y, ptr addrspace(5) %1, align 4
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void @vararg(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  tail call void (...) @vararg(<32 x float> noundef %x, i32 noundef %y) #2
  ret void
}

define hidden void @indirect_single_i32(i32 noundef %x) {
; CHECK-LABEL: define {{[^@]+}}@indirect_single_i32(i32 noundef %x) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %vararg_buffer = alloca %indirect_single_i32.vararg, align 4, addrspace(5)
; CHECK-NEXT:    %0 = load volatile ptr, ptr addrspacecast (ptr addrspace(1) @vararg_ptr to ptr), align 8, !tbaa !3
; CHECK-NEXT:    %1 = getelementptr inbounds %indirect_single_i32.vararg, ptr addrspace(5) %vararg_buffer, i32 0, i32 0
; CHECK-NEXT:    store i32 %x, ptr addrspace(5) %1, align 4
; CHECK-NEXT:    %2 = addrspacecast ptr addrspace(5) %vararg_buffer to ptr
; CHECK-NEXT:    call void %0(ptr %2) #3
; CHECK-NEXT:    ret void
;
entry:
  %0 = load volatile ptr, ptr addrspacecast (ptr addrspace(1) @vararg_ptr to ptr), align 8, !tbaa !4
  tail call void (...) %0(i32 noundef %x) #2
  ret void
}

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { nocallback nofree nosync nounwind willreturn }
attributes #2 = { mustprogress }

!llvm.module.flags = !{!0, !1, !2}

!0 = !{i32 1, !"amdgpu_code_object_version", i32 500}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 8, !"PIC Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any pointer", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
